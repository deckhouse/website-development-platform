---
title: Хранилище (store) для действий в BPMN — руководство
menuTitle: Store (BPMN)
d8Edition: ee
moduleStatus: experimental
---

В этом документе описано, как устроен **store** в процессах BPMN и как им пользоваться: как данные попадают в store и как следующие действия их читают.

## 1. Что такое store

Store — это **плоская** ключ–значение map **в рамках одного инстанса процесса**. В нём лежат только те данные, которые явно записываются по правилам действий. Другой инстанс того же процесса имеет свой store.

- **Один store на инстанс процесса** — у каждого запуска процесса свой store.
- **Плоские ключи** — в store нет уровня «слаг задачи», только логические ключи (например `projectId`, `deployJobId`).
- **Запись только по правилам** — в store пишется только то, что задано в настройках действия (Response to store rules). Если правил нет — в store ничего не записывается.
- **Чтение через плейсхолдеры** — в конфиге действия (URL, заголовки, body и т.д.) можно использовать Go-шаблоны вида `{{ .store.<ключ> }}`.

## 2. Как данные попадают в store

### Правила на действии (Response to store rules)

У **действия** в разделе «Обновление» (Update) есть блок **«Запись в store процесса»** (Write to process store). В нём задаётся список правил:

| Поле | Значение | Описание |
|------|----------|----------|
| **Source** | Строка Go-шаблона | Выражение с контекстом = **response** этого действия. Примеры: `{{ .id }}`, `{{ .name }}`, `{{ .result.projectId }}`. Шаблон выполняется один раз после успешного выполнения действия; результат (строка) записывается в store. |
| **Target** | Ключ в store | Имя ключа в store процесса (например `projectId`, `deployJobId`). Под этим ключом будет сохранено значение из Source. |

- Если у действия **нет ни одного правила** (список пустой) — при успешном выполнении задачи в store **ничего не пишется**.
- Если правила есть — после успешного завершения задачи для каждого правила выполняется шаблон Source с контекстом response, и результат записывается в store под ключом Target.

### Когда выполняется запись

1. Задача процесса с этим действием завершилась **успешно** (статус action record = Success).
2. У действия задан **непустой** список правил Response to store.
3. Для каждого правила: выполняется Go-шаблон (Source) с данными response; полученная строка записывается в store под ключом Target.

Если для одного и того же ключа Target пишут несколько задач (или одно и то же действие при повторном запуске), **значение перезаписывается**. В логах при перезаписи существующего ключа пишется предупреждение (Warn): store key already exists, data will be overwritten.

## 3. Как читать из store в других действиях

В любом **последующем** действии того же инстанса процесса в полях, поддерживающих плейсхолдеры (URL, заголовки, body и т.д.), можно использовать:

- **Синтаксис:** `{{ .store.<ключ> }}`

`<ключ>` — это Target из правил Response to store (например `projectId`, `deployJobId`). В store лежат только такие плоские ключи.

### Примеры

- URL с ID проекта из предыдущего шага:

```yaml
url: "https://api.example.com/projects/{{ .store.projectId }}/deploy"
```

- Несколько ключей из store в одном действии:

```yaml
headers:
  X-Project-Id: "{{ .store.projectId }}"
  X-Job-Id: "{{ .store.deployJobId }}"
body: |
  {"ref": "{{ .store.orderRef }}"}
```

Действие, которое **читает** из store, не обязано знать, какое именно действие или задача записало значение — достаточно знать **имя ключа** (Target), которое объявлено в процессе (в настройках действий, которые что-то пишут в store).

## 4. Поведение при отсутствующих данных

- Если **ключа нет** в store (задача ещё не выполнялась, не имела правил записи или запись не произошла), плейсхолдер `{{ .store.<ключ> }}` подставляется как **пустая строка**.
- Действие при этом **не падает** — запрос уходит с пустым значением в этом месте.

То есть можно безопасно ссылаться на ключи, которых ещё нет в store.

## 5. Краткая схема

| Вопрос | Ответ |
|--------|--------|
| **Где хранится store** | В данных инстанса процесса. Один store на инстанс. |
| **Что в store** | Только пары ключ–значение, записанные по правилам Response to store (плоский набор ключей). |
| **Как записать** | В настройках **действия** добавить правила «Response to store»: Source — Go-шаблон по response (например `{{ .id }}`), Target — ключ в store (например `projectId`). После успешного выполнения задачи значения по правилам попадут в store. |
| **Как читать** | В конфиге другого действия использовать `{{ .store.<ключ> }}`, где `<ключ>` — один из Target из правил. |
| **Нет правил у действия** | В store при выполнении этого действия ничего не записывается. |
| **Один ключ пишут несколько раз** | Остаётся последнее записанное значение; в лог пишется предупреждение о перезаписи. |
| **Ключа нет в store** | Плейсхолдер даёт пустую строку, действие не падает. |

## 6. Пример сценария

1. Действие «Создать проект» настроено с правилами Response to store:
   - Source: `{{ .id }}`, Target: `projectId`
   - Source: `{{ .name }}`, Target: `projectName`
2. Задача с этим действием выполнилась успешно; response был `{ "id": "123", "name": "My Project" }`.
3. В store инстанса записалось: `projectId` = "123", `projectName` = "My Project".
4. Следующая задача в процессе использует действие с URL:  
   `https://api.example.com/projects/{{ .store.projectId }}/deploy`  
   В момент выполнения подставится `projectId` = "123".

## 7. Проверка store через действие Debug

Чтобы проверить запись и чтение из store, удобно использовать встроенное действие **Debug**.

1. **Добавьте задачу с действием Debug** в процесс (или создайте процесс с одной такой задачей).
2. **Тело запроса Debug** (body) задаёт данные, которые попадут в response. Debug кладёт в response те же поля, что и в запросе: `sleep_time`, `sleep_count`, `extra`. В `extra` можно положить произвольные ключи — они будут доступны в шаблонах как `{{ .extra.<ключ> }}`.

   Пример body для Debug (поля из `extra` и верхнего уровня попадают в response и доступны в шаблонах как `{{ .extra.projectId }}`, `{{ .sleep_time }}` и т.д.):

```yaml
sleep_time: 1
sleep_count: 1
extra:
  example_key: example_value
  projectId: "test-123"
  message: "hello from debug"
```

   Если в body нет `extra.projectId` или `extra.message`, в store эти ключи не попадут (шаблон даст пустое значение, запись в store для пустых не выполняется).

1. **Настройте «Запись в store процесса»** у этого действия:
   - Правило 1: Source — `{{ .extra.projectId }}`, Target — `projectId`
   - Правило 2: Source — `{{ .extra.message }}`, Target — `debugMessage`

1. После успешного выполнения задачи в store появятся ключи `projectId` и `debugMessage`. В **следующей** задаче процесса в конфиге действия используйте, например:
   - URL или body: `{{ .store.projectId }}`, `{{ .store.debugMessage }}`

Так можно убедиться, что данные из Debug через правила попадают в store и доступны в следующих действиях.
